// -----------------------------------------------------------------------
// <copyright file="ForEachNode.cs" company="Microsoft Corp.">
//     Copyright (c) Microsoft Corp. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace ExecutionEngine.Nodes;

using System.Collections;
using ExecutionEngine.Contexts;
using ExecutionEngine.Core;
using ExecutionEngine.Enums;
using ExecutionEngine.Factory;
using ExecutionEngine.Messages;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.Scripting;

/// <summary>
/// Node that iterates over a collection and executes downstream nodes for each item.
/// Uses Roslyn scripting engine to evaluate collection expressions.
/// Emits NodeNextMessage for each iteration and NodeCompleteMessage when done.
/// </summary>
public class ForEachNode : ExecutableNodeBase
{
    /// <summary>
    /// Port name for loop body iteration messages.
    /// </summary>
    public const string LoopBodyPort = "LoopBody";

    /// <summary>
    /// Gets or sets the expression that returns a collection to iterate over.
    /// This should be a valid C# expression that evaluates to IEnumerable.
    /// </summary>
    public string CollectionExpression { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the variable name for the current item in each iteration.
    /// Defaults to "item".
    /// </summary>
    public string ItemVariableName { get; set; } = "item";

    /// <inheritdoc/>
    public override void Initialize(NodeDefinition definition)
    {
        base.Initialize(definition);

        // Get collection expression from definition configuration
        if (definition.Configuration != null)
        {
            if (definition.Configuration.TryGetValue("CollectionExpression", out var collectionValue))
            {
                this.CollectionExpression = collectionValue?.ToString() ?? string.Empty;
            }

            if (definition.Configuration.TryGetValue("ItemVariableName", out var itemVarValue))
            {
                this.ItemVariableName = itemVarValue?.ToString() ?? "item";
            }
        }
    }

    /// <inheritdoc/>
    public string[] GetAvailablePorts()
    {
        // ForEach node has two output ports:
        // 1. LoopBody - emits Next message for each iteration
        // 2. Default - emits Complete message when loop finishes
        return new[] { LoopBodyPort };
    }

    /// <inheritdoc/>
    public override async Task<NodeInstance> ExecuteAsync(
        WorkflowExecutionContext workflowContext,
        NodeExecutionContext nodeContext,
        CancellationToken cancellationToken)
    {
        var instance = this.CreateNodeInstance(workflowContext);
        instance.Status = NodeExecutionStatus.Running;

        try
        {
            this.RaiseOnStart(new NodeStartedEvent
            {
                NodeId = this.NodeId,
                NodeName = this.NodeName,
                WorkflowInstanceId = workflowContext.InstanceId,
                Timestamp = DateTime.UtcNow
            });

            // Evaluate collection expression
            var collection = await this.EvaluateCollectionAsync(workflowContext, nodeContext, cancellationToken);

            if (collection == null)
            {
                instance.Status = NodeExecutionStatus.Failed;
                instance.EndTime = DateTime.UtcNow;
                instance.ErrorMessage = "Collection expression evaluated to null";
                return instance;
            }

            // Iterate over collection
            var itemCount = 0;
            var totalCount = collection.Cast<object>().Count();

            foreach (var item in collection)
            {
                cancellationToken.ThrowIfCancellationRequested();

                // Set item variables in workflow context
                workflowContext.Variables[this.ItemVariableName] = item;
                workflowContext.Variables[$"{this.ItemVariableName}Index"] = itemCount;

                // Emit progress event
                this.RaiseOnProgress(new ProgressUpdate
                {
                    NodeId = this.NodeId,
                    PercentComplete = totalCount > 0 ? (int)((itemCount * 100.0) / totalCount) : 0,
                    Message = $"Processing item {itemCount + 1} of {totalCount}",
                    Timestamp = DateTime.UtcNow
                });

                // Emit Next message for this iteration (routed to LoopBody port)
                var nextMessage = new NodeNextMessage
                {
                    SourceNodeId = this.NodeId,
                    Timestamp = DateTime.UtcNow,
                    OutputData = new Dictionary<string, object>
                    {
                        [this.ItemVariableName] = item,
                        [$"{this.ItemVariableName}Index"] = itemCount
                    },
                    SourcePort = LoopBodyPort
                };

                // Route the message to downstream nodes
                await workflowContext.Router.RouteMessageAsync(nextMessage, cancellationToken);

                itemCount++;
            }

            // Store iteration results in output data
            nodeContext.OutputData["ItemsProcessed"] = itemCount;
            nodeContext.OutputData["CollectionExpression"] = this.CollectionExpression;

            instance.Status = NodeExecutionStatus.Completed;
            instance.EndTime = DateTime.UtcNow;

            this.RaiseOnCompleted(new NodeCompletedEvent
            {
                NodeId = this.NodeId,
                NodeName = this.NodeName,
                WorkflowInstanceId = workflowContext.InstanceId,
                Timestamp = DateTime.UtcNow,
                OutputData = nodeContext.OutputData
            });
        }
        catch (OperationCanceledException)
        {
            instance.Status = NodeExecutionStatus.Cancelled;
            instance.EndTime = DateTime.UtcNow;
            instance.ErrorMessage = "Node execution was cancelled";
        }
        catch (Exception ex)
        {
            instance.Status = NodeExecutionStatus.Failed;
            instance.EndTime = DateTime.UtcNow;
            instance.ErrorMessage = ex.Message;
            instance.Exception = ex;

            this.RaiseOnFailed(new NodeFailedEvent
            {
                NodeId = this.NodeId,
                NodeName = this.NodeName,
                WorkflowInstanceId = workflowContext.InstanceId,
                Timestamp = DateTime.UtcNow,
                Exception = ex,
                ErrorMessage = ex.Message
            });
        }

        return instance;
    }

    /// <summary>
    /// Evaluates the collection expression using Roslyn scripting.
    /// </summary>
    /// <param name="workflowContext">The workflow execution context.</param>
    /// <param name="nodeContext">The node execution context.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The evaluated collection as IEnumerable.</returns>
    private async Task<IEnumerable?> EvaluateCollectionAsync(
        WorkflowExecutionContext workflowContext,
        NodeExecutionContext nodeContext,
        CancellationToken cancellationToken)
    {
        if (string.IsNullOrWhiteSpace(this.CollectionExpression))
        {
            throw new InvalidOperationException("CollectionExpression cannot be null or empty");
        }

        // Create execution state for script evaluation
        var state = new ExecutionState
        {
            WorkflowContext = workflowContext,
            NodeContext = nodeContext
        };

        try
        {
            // Evaluate the collection expression
            var scriptOptions = ScriptOptions.Default
                .AddReferences(typeof(object).Assembly)
                .AddReferences(typeof(Enumerable).Assembly)
                .AddImports("System")
                .AddImports("System.Collections")
                .AddImports("System.Collections.Generic")
                .AddImports("System.Linq");

            var result = await CSharpScript.EvaluateAsync<object>(
                this.CollectionExpression,
                scriptOptions,
                state,
                cancellationToken);

            // Convert result to IEnumerable
            if (result is IEnumerable enumerable)
            {
                return enumerable;
            }

            throw new InvalidOperationException(
                $"Collection expression did not return an IEnumerable. Returned type: {result?.GetType().Name ?? "null"}");
        }
        catch (CompilationErrorException ex)
        {
            var errors = string.Join(", ", ex.Diagnostics.Select(d => d.GetMessage()));
            throw new InvalidOperationException($"Collection expression compilation failed: {errors}", ex);
        }
    }
}
