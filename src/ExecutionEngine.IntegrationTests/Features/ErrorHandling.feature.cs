// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated by Reqnroll (https://reqnroll.net/).
//      Reqnroll Version:3.0.0.0
//      Reqnroll Generator Version:3.0.0.0
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------
#region Designer generated code
#pragma warning disable
using Reqnroll;
namespace ExecutionEngine.IntegrationTests.Features
{
    
    
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Reqnroll", "3.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestClassAttribute()]
    public partial class ErrorHandlingFeature
    {
        
        private global::Reqnroll.ITestRunner testRunner;
        
        private Microsoft.VisualStudio.TestTools.UnitTesting.TestContext _testContext;
        
        private static string[] featureTags = ((string[])(null));
        
        private static global::Reqnroll.FeatureInfo featureInfo = new global::Reqnroll.FeatureInfo(new global::System.Globalization.CultureInfo("en-US"), "Features", "Error Handling", "  As a workflow engine\r\n  I want to handle failures gracefully\r\n  So that workflo" +
                "ws can recover from errors", global::Reqnroll.ProgrammingLanguage.CSharp, featureTags, InitializeCucumberMessages());
        
#line 1 "ErrorHandling.feature"
#line hidden
        
        public virtual Microsoft.VisualStudio.TestTools.UnitTesting.TestContext TestContext
        {
            get
            {
                return this._testContext;
            }
            set
            {
                this._testContext = value;
            }
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.ClassInitializeAttribute()]
        public static async global::System.Threading.Tasks.Task FeatureSetupAsync(Microsoft.VisualStudio.TestTools.UnitTesting.TestContext testContext)
        {
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.ClassCleanupAttribute(Microsoft.VisualStudio.TestTools.UnitTesting.ClassCleanupBehavior.EndOfClass)]
        public static async global::System.Threading.Tasks.Task FeatureTearDownAsync()
        {
            await global::Reqnroll.TestRunnerManager.ReleaseFeatureAsync(featureInfo);
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestInitializeAttribute()]
        public async global::System.Threading.Tasks.Task TestInitializeAsync()
        {
            testRunner = global::Reqnroll.TestRunnerManager.GetTestRunnerForAssembly(featureHint: featureInfo);
            try
            {
                if (((testRunner.FeatureContext != null) 
                            && (testRunner.FeatureContext.FeatureInfo.Equals(featureInfo) == false)))
                {
                    await testRunner.OnFeatureEndAsync();
                }
            }
            finally
            {
                if (((testRunner.FeatureContext != null) 
                            && testRunner.FeatureContext.BeforeFeatureHookFailed))
                {
                    throw new global::Reqnroll.ReqnrollException("Scenario skipped because of previous before feature hook error");
                }
                if ((testRunner.FeatureContext == null))
                {
                    await testRunner.OnFeatureStartAsync(featureInfo);
                }
            }
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCleanupAttribute()]
        public async global::System.Threading.Tasks.Task TestTearDownAsync()
        {
            if ((testRunner == null))
            {
                return;
            }
            try
            {
                await testRunner.OnScenarioEndAsync();
            }
            finally
            {
                global::Reqnroll.TestRunnerManager.ReleaseTestRunner(testRunner);
                testRunner = null;
            }
        }
        
        public void ScenarioInitialize(global::Reqnroll.ScenarioInfo scenarioInfo, global::Reqnroll.RuleInfo ruleInfo)
        {
            testRunner.OnScenarioInitialize(scenarioInfo, ruleInfo);
            testRunner.ScenarioContext.ScenarioContainer.RegisterInstanceAs<Microsoft.VisualStudio.TestTools.UnitTesting.TestContext>(_testContext);
        }
        
        public async global::System.Threading.Tasks.Task ScenarioStartAsync()
        {
            await testRunner.OnScenarioStartAsync();
        }
        
        public async global::System.Threading.Tasks.Task ScenarioCleanupAsync()
        {
            await testRunner.CollectScenarioErrorsAsync();
        }
        
        private static global::Reqnroll.Formatters.RuntimeSupport.FeatureLevelCucumberMessages InitializeCucumberMessages()
        {
            return new global::Reqnroll.Formatters.RuntimeSupport.FeatureLevelCucumberMessages("Features/ErrorHandling.feature.ndjson", 16);
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Node execution failure")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Node execution failure")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("smoke")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task NodeExecutionFailure()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "smoke",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "0";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Node execution failure", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 7
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 8
    await testRunner.GivenAsync("I have a workflow with nodes \"Task\", \"ErrorHandler\", \"SuccessHandler\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 9
    await testRunner.AndAsync("\"Task\" connects to \"SuccessHandler\" on Complete", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 10
    await testRunner.AndAsync("\"Task\" connects to \"ErrorHandler\" on Fail", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 11
    await testRunner.AndAsync("\"Task\" is configured to throw an exception", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 12
    await testRunner.WhenAsync("I start the workflow", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 13
    await testRunner.ThenAsync("\"Task\" should fail with an error", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 14
    await testRunner.AndAsync("NodeFailed event should fire for \"Task\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 15
    await testRunner.AndAsync("\"ErrorHandler\" should execute", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 16
    await testRunner.AndAsync("\"SuccessHandler\" should not execute", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 17
    await testRunner.AndAsync("the error message should be captured in NodeInstance", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Retry policy execution")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Retry policy execution")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task RetryPolicyExecution()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "1";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Retry policy execution", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 20
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
                global::Reqnroll.Table table7 = new global::Reqnroll.Table(new string[] {
                            "MaxAttempts",
                            "Delay",
                            "BackoffMultiplier"});
                table7.AddRow(new string[] {
                            "3",
                            "100ms",
                            "2.0"});
#line 21
    await testRunner.GivenAsync("I have a node \"FlakyTask\" with retry policy:", ((string)(null)), table7, "Given ");
#line hidden
#line 24
    await testRunner.AndAsync("\"FlakyTask\" fails on attempts 1 and 2, succeeds on attempt 3", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 25
    await testRunner.WhenAsync("I start the workflow", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 26
    await testRunner.ThenAsync("\"FlakyTask\" should be attempted 3 times", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 27
    await testRunner.AndAsync("there should be delays between retries", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 28
    await testRunner.AndAsync("the final attempt should succeed", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 29
    await testRunner.AndAsync("the workflow should complete successfully", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Retry exhausted triggers failure")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Retry exhausted triggers failure")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task RetryExhaustedTriggersFailure()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "2";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Retry exhausted triggers failure", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 32
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 33
    await testRunner.GivenAsync("I have a node with retry policy MaxAttempts = 3", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 34
    await testRunner.AndAsync("the node always fails", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 35
    await testRunner.WhenAsync("I start the workflow", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 36
    await testRunner.ThenAsync("the node should be retried 3 times", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 37
    await testRunner.AndAsync("after final retry failure, the node should fail permanently", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 38
    await testRunner.AndAsync("OnFail connections should be triggered", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 39
    await testRunner.AndAsync("the workflow should fail", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Circuit breaker pattern")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Circuit breaker pattern")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task CircuitBreakerPattern()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "3";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Circuit breaker pattern", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 42
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
                global::Reqnroll.Table table8 = new global::Reqnroll.Table(new string[] {
                            "FailureThreshold",
                            "Timeout",
                            "FallbackNodeId"});
                table8.AddRow(new string[] {
                            "3",
                            "5 seconds",
                            "FallbackNode"});
#line 43
    await testRunner.GivenAsync("I have a node \"UnreliableService\" with circuit breaker:", ((string)(null)), table8, "Given ");
#line hidden
#line 46
    await testRunner.AndAsync("\"UnreliableService\" fails 3 times in a row", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 47
    await testRunner.WhenAsync("the circuit breaker opens", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 48
    await testRunner.ThenAsync("subsequent calls should not execute \"UnreliableService\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 49
    await testRunner.AndAsync("\"FallbackNode\" should execute instead", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 50
    await testRunner.AndAsync("after timeout expires, circuit should allow retry", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 51
    await testRunner.AndAsync("success should close the circuit", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Compensation transaction execution")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Compensation transaction execution")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task CompensationTransactionExecution()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "4";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Compensation transaction execution", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 54
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 55
    await testRunner.GivenAsync("I have a workflow with nodes \"Step1\", \"Step2\", \"Step3\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 56
    await testRunner.AndAsync("\"Step1\" has compensation node \"UndoStep1\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 57
    await testRunner.AndAsync("\"Step2\" has compensation node \"UndoStep2\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 58
    await testRunner.AndAsync("\"Step3\" is configured to fail", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 59
    await testRunner.WhenAsync("I start the workflow", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 60
    await testRunner.ThenAsync("\"Step1\" and \"Step2\" should complete successfully", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 61
    await testRunner.AndAsync("\"Step3\" should fail", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 62
    await testRunner.AndAsync("compensation should execute in reverse order: UndoStep2, UndoStep1", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 63
    await testRunner.AndAsync("compensation results should be logged", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 64
    await testRunner.AndAsync("the workflow should fail with original error preserved", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Workflow timeout")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Workflow timeout")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("slow")]
        public async global::System.Threading.Tasks.Task WorkflowTimeout()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling",
                    "slow"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "5";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Workflow timeout", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 67
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 68
    await testRunner.GivenAsync("I have a workflow with timeout 500 milliseconds", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 69
    await testRunner.AndAsync("the workflow contains long-running nodes", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 70
    await testRunner.WhenAsync("I start the workflow", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 71
    await testRunner.ThenAsync("the workflow should be cancelled after 500 milliseconds", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 72
    await testRunner.AndAsync("a TimeoutException should be thrown", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 73
    await testRunner.AndAsync("the workflow status should be \"Cancelled\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 74
    await testRunner.AndAsync("partial results should be preserved", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Graceful degradation with fallback nodes")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Graceful degradation with fallback nodes")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task GracefulDegradationWithFallbackNodes()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "6";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Graceful degradation with fallback nodes", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 77
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 78
    await testRunner.GivenAsync("I have node \"Primary\" with fallback \"Secondary\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 79
    await testRunner.AndAsync("\"Primary\" circuit breaker is open", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 80
    await testRunner.WhenAsync("I start the workflow", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 81
    await testRunner.ThenAsync("\"Primary\" should not execute", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 82
    await testRunner.AndAsync("\"Secondary\" should execute as fallback", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 83
    await testRunner.AndAsync("the workflow should complete successfully", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 84
    await testRunner.AndAsync("output should indicate fallback was used", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Dead letter queue threshold alerts")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Dead letter queue threshold alerts")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task DeadLetterQueueThresholdAlerts()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "7";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Dead letter queue threshold alerts", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 87
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 88
    await testRunner.GivenAsync("I have a dead letter queue with max size 10", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 89
    await testRunner.AndAsync("10 messages have failed and been added to DLQ", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 90
    await testRunner.WhenAsync("an 11th message fails", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 91
    await testRunner.ThenAsync("the oldest DLQ entry should be removed", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 92
    await testRunner.AndAsync("the new message should be added", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 93
    await testRunner.AndAsync("DLQ size should remain at 10", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Partial workflow recovery")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Partial workflow recovery")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task PartialWorkflowRecovery()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "8";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Partial workflow recovery", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 96
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 97
    await testRunner.GivenAsync("I have a workflow that fails at node \"Step5\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 98
    await testRunner.AndAsync("nodes \"Step1\" through \"Step4\" completed successfully", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 99
    await testRunner.WhenAsync("I resume the workflow from checkpoint", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 100
    await testRunner.ThenAsync("nodes \"Step1\" through \"Step4\" should not re-execute", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 101
    await testRunner.AndAsync("execution should resume at \"Step5\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 102
    await testRunner.AndAsync("the workflow should complete if \"Step5\" succeeds", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Exception details preserved")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Exception details preserved")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task ExceptionDetailsPreserved()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "9";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Exception details preserved", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 105
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 106
    await testRunner.GivenAsync("I have a node that throws a specific exception type", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 107
    await testRunner.WhenAsync("the node executes and fails", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 108
    await testRunner.ThenAsync("the exception message should be captured", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 109
    await testRunner.AndAsync("the exception stack trace should be available", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 110
    await testRunner.AndAsync("the exception type should be preserved", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 111
    await testRunner.AndAsync("all details should be in NodeInstance error data", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Cascading failure prevention")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Cascading failure prevention")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task CascadingFailurePrevention()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "10";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Cascading failure prevention", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 114
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 115
    await testRunner.GivenAsync("I have a workflow with error handlers", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 116
    await testRunner.AndAsync("node \"A\" fails", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 117
    await testRunner.WhenAsync("error handler \"HandleA\" also fails", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 118
    await testRunner.ThenAsync("the workflow should not enter infinite error handling", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 119
    await testRunner.AndAsync("appropriate failure should be recorded", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 120
    await testRunner.AndAsync("the workflow should fail gracefully", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Timeout on individual node")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Timeout on individual node")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task TimeoutOnIndividualNode()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "11";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Timeout on individual node", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 123
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 124
    await testRunner.GivenAsync("I have a node with timeout 200 milliseconds", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 125
    await testRunner.AndAsync("the node executes for 500 milliseconds", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 126
    await testRunner.WhenAsync("I start the workflow", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 127
    await testRunner.ThenAsync("the node should be cancelled after 200 milliseconds", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 128
    await testRunner.AndAsync("the node status should be \"Cancelled\"", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 129
    await testRunner.AndAsync("timeout error should be recorded", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Retry with exponential backoff")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Retry with exponential backoff")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task RetryWithExponentialBackoff()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "12";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Retry with exponential backoff", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 132
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
                global::Reqnroll.Table table9 = new global::Reqnroll.Table(new string[] {
                            "MaxAttempts",
                            "InitialDelay",
                            "BackoffMultiplier"});
                table9.AddRow(new string[] {
                            "4",
                            "100ms",
                            "2.0"});
#line 133
    await testRunner.GivenAsync("I have a node with retry policy:", ((string)(null)), table9, "Given ");
#line hidden
#line 136
    await testRunner.WhenAsync("the node fails repeatedly", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 137
    await testRunner.ThenAsync("retry delays should be approximately 100ms, 200ms, 400ms", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 138
    await testRunner.AndAsync("total retry time should reflect exponential backoff", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 139
    await testRunner.AndAsync("backoff should prevent thundering herd", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
        
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestMethodAttribute("Selective retry based on exception type")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute("Selective retry based on exception type")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestPropertyAttribute("FeatureTitle", "Error Handling")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("integration")]
        [global::Microsoft.VisualStudio.TestTools.UnitTesting.TestCategoryAttribute("errorhandling")]
        public async global::System.Threading.Tasks.Task SelectiveRetryBasedOnExceptionType()
        {
            string[] tagsOfScenario = new string[] {
                    "integration",
                    "errorhandling"};
            global::System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new global::System.Collections.Specialized.OrderedDictionary();
            string pickleIndex = "13";
            global::Reqnroll.ScenarioInfo scenarioInfo = new global::Reqnroll.ScenarioInfo("Selective retry based on exception type", null, tagsOfScenario, argumentsOfScenario, featureTags, pickleIndex);
            string[] tagsOfRule = ((string[])(null));
            global::Reqnroll.RuleInfo ruleInfo = null;
#line 142
  this.ScenarioInitialize(scenarioInfo, ruleInfo);
#line hidden
            if ((global::Reqnroll.TagHelper.ContainsIgnoreTag(scenarioInfo.CombinedTags) || global::Reqnroll.TagHelper.ContainsIgnoreTag(featureTags)))
            {
                await testRunner.SkipScenarioAsync();
            }
            else
            {
                await this.ScenarioStartAsync();
#line 143
    await testRunner.GivenAsync("I have a node with retry policy that retries on TransientException", ((string)(null)), ((global::Reqnroll.Table)(null)), "Given ");
#line hidden
#line 144
    await testRunner.AndAsync("the policy does not retry on PermanentException", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
#line 145
    await testRunner.WhenAsync("the node throws TransientException", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 146
    await testRunner.ThenAsync("retries should be attempted", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 147
    await testRunner.WhenAsync("the node throws PermanentException", ((string)(null)), ((global::Reqnroll.Table)(null)), "When ");
#line hidden
#line 148
    await testRunner.ThenAsync("no retries should be attempted", ((string)(null)), ((global::Reqnroll.Table)(null)), "Then ");
#line hidden
#line 149
    await testRunner.AndAsync("the node should fail immediately", ((string)(null)), ((global::Reqnroll.Table)(null)), "And ");
#line hidden
            }
            await this.ScenarioCleanupAsync();
        }
    }
}
#pragma warning restore
#endregion
